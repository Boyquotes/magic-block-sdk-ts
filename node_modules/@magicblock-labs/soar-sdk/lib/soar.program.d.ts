/// <reference types="node" />
import { type AnchorProvider, Program, type Provider } from "@coral-xyz/anchor";
import { PublicKey, type ConfirmOptions, type Connection, type GetProgramAccountsFilter, type Signer, type Transaction } from "@solana/web3.js";
import { type Soar } from "./idl/soar";
import type BN from "bn.js";
import { Utils } from "./utils";
import { type InstructionResult } from "./types";
import { AchievementAccount, GameAccount, type GameAttributes, type GameType, type Genre, LeaderBoardAccount, MergedAccount, PlayerAccount, PlayerAchievementAccount, PlayerScoresListAccount, RewardAccount, TopEntriesAccount } from "./state";
import { GameClient } from "./soar.game";
export declare class SimpleProvider implements Provider {
    readonly connection: Connection;
    readonly publicKey?: PublicKey;
    constructor(connection: Connection, publicKey?: PublicKey);
}
export declare class SoarProgram {
    readonly provider: AnchorProvider;
    readonly program: Program<Soar>;
    readonly utils: Utils;
    private readonly builder;
    private constructor();
    static getFromConnection(connection: Connection, defaultPayer: PublicKey, programId?: PublicKey): SoarProgram;
    static get(provider: AnchorProvider, programId?: PublicKey): SoarProgram;
    initializeNewGame(newGame: PublicKey | string, title: string, description: string, genre: Genre, gameType: GameType, nftMeta: PublicKey | string, authorities: PublicKey[]): Promise<InstructionResult.InitializeGame>;
    initializePlayerAccount(user: PublicKey | string, username: string, nftMeta: PublicKey | string): Promise<InstructionResult.InitializePlayer>;
    updateGameAccount(game: PublicKey | string, authority: PublicKey | string, newMeta?: GameAttributes, newAuths?: PublicKey[]): Promise<InstructionResult.UpdateGame>;
    updatePlayerAccount(user: PublicKey | string, newUsername?: string, newNftMeta?: PublicKey | string): Promise<InstructionResult.UpdatePlayer>;
    initiateMerge(user: PublicKey | string, newMergeAccount: PublicKey | string, playerAccountKeys: PublicKey[]): Promise<InstructionResult.InitiateMerge>;
    registerMergeApproval(user: PublicKey | string, mergeAccount: PublicKey | string): Promise<InstructionResult.RegisterMergeApproval>;
    addNewGameAchievement(gameAddress: PublicKey | string, authority: PublicKey | string, title: string, description: string, nftMeta: PublicKey | string): Promise<InstructionResult.AddGameAchievement>;
    addNewGameLeaderBoard(gameAddress: PublicKey | string, authority: PublicKey | string, description: string, nftMeta: PublicKey | string, scoresToRetain: number, scoresOrder: boolean, decimals?: number, minScore?: BN, maxScore?: BN, allowMultipleScores?: boolean): Promise<InstructionResult.AddLeaderBoard>;
    updateGameLeaderboard(authority: PublicKey | string, leaderboard: PublicKey | string, newDescription?: string, newNftMeta?: PublicKey | string, newMinScore?: BN, newMaxScore?: BN, newIsAscending?: boolean, newAllowMultipleScores?: boolean, topEntries?: PublicKey | string): Promise<InstructionResult.UpdateLeaderboard>;
    registerPlayerEntryForLeaderBoard(user: PublicKey | string, leaderboard: PublicKey | string): Promise<InstructionResult.RegisterPlayerEntry>;
    submitScoreToLeaderBoard(user: PublicKey | string, authority: PublicKey | string, leaderboard: PublicKey | string, score: BN): Promise<InstructionResult.SubmitScore>;
    updateGameAchievement(authority: PublicKey | string, achievement: PublicKey | string, newTitle?: string, newDescription?: string, newNftMeta?: PublicKey | string): Promise<InstructionResult.UpdateAchievement>;
    unlockPlayerAchievement(user: PublicKey | string, authority: PublicKey | string, achievement: PublicKey | string, leaderboard: PublicKey | string, game?: PublicKey | string): Promise<InstructionResult.UnlockPlayerAchievement>;
    addFungibleReward(authority: PublicKey | string, newReward: PublicKey | string, achievement: PublicKey | string, amountPerUser: BN, availableRewards: BN, initialDelegation: BN, mint: PublicKey, sourceTokenAccount: PublicKey | string, tokenAccountOwner: PublicKey | string): Promise<InstructionResult.AddReward>;
    addNonFungibleReward(authority: PublicKey | string, newReward: PublicKey | string, achievement: PublicKey | string, availableRewards: BN, uri: string, name: string, symbol: string, collectionMint?: PublicKey | string, collectionUpdateAuthority?: PublicKey | string): Promise<InstructionResult.AddReward>;
    claimNftReward(authority: PublicKey | string, achievement: PublicKey | string, mint: PublicKey | string, user: PublicKey | string): Promise<InstructionResult.ClaimNftReward>;
    claimFtReward(authority: PublicKey | string, achievement: PublicKey | string, user: PublicKey | string): Promise<InstructionResult.ClaimFtReward>;
    verifyPlayerNftReward(user: PublicKey | string, achievement: PublicKey | string, mint: PublicKey | string): Promise<InstructionResult.VerifyReward>;
    private createATA;
    sendAndConfirmTransaction(transaction: Transaction, signers?: Signer[], opts?: ConfirmOptions): Promise<string>;
    sendAndConfirmTransactions(transactions: Transaction[], signers?: Signer[][], opts?: ConfirmOptions): Promise<string[]>;
    newGameClient(gameAddress: PublicKey): Promise<GameClient>;
    fetchAchievementAccount(address: PublicKey): Promise<AchievementAccount>;
    fetchGameAccount(address: PublicKey): Promise<GameAccount>;
    fetchLeaderBoardAccount(address: PublicKey): Promise<LeaderBoardAccount>;
    fetchLeaderBoardTopEntriesAccount(address: PublicKey): Promise<TopEntriesAccount>;
    fetchMergedAccount(address: PublicKey): Promise<MergedAccount>;
    fetchPlayerAchievementAccount(address: PublicKey): Promise<PlayerAchievementAccount>;
    fetchPlayerScoresListAccount(address: PublicKey): Promise<PlayerScoresListAccount>;
    fetchPlayerAccount(address: PublicKey): Promise<PlayerAccount>;
    fetchRewardAccount(address: PublicKey): Promise<RewardAccount>;
    fetchAllGameAccounts(memcmp?: Buffer | GetProgramAccountsFilter[]): Promise<GameAccount[]>;
    fetchAllAchievementAccounts(memcmp?: Buffer | GetProgramAccountsFilter[]): Promise<AchievementAccount[]>;
    fetchAllLeaderboardAccounts(memcmp?: Buffer | GetProgramAccountsFilter[]): Promise<LeaderBoardAccount[]>;
    fetchAllPlayerAccounts(memcmp?: Buffer | GetProgramAccountsFilter[]): Promise<PlayerAccount[]>;
    fetchGameAccountsInfoByGenre(genre: string): Promise<GameAccount[]>;
    fetchPlayerAchievementInfo(user: PublicKey): Promise<PlayerAchievementAccount[]>;
    private getPublicKey;
    private getNullablePublicKey;
}
//# sourceMappingURL=soar.program.d.ts.map