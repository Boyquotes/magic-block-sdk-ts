"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountsBuilder = void 0;
var soar_1 = require("../idl/soar");
var anchor_1 = require("@coral-xyz/anchor");
var web3_js_1 = require("@solana/web3.js");
var constants_1 = require("../constants");
var utils_1 = require("../utils");
var spl_token_1 = require("@solana/spl-token");
var state_1 = require("../state");
var AccountsBuilder = (function () {
    function AccountsBuilder(provider, programId) {
        var _this = this;
        this.provider = provider;
        this.initializeGameAccounts = function (game, creator) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, {
                        creator: creator != null ? creator : this.provider.publicKey,
                        game: game,
                        systemProgram: web3_js_1.SystemProgram.programId,
                    }];
            });
        }); };
        this.initializePlayerAccounts = function (user, payer) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, {
                        playerAccount: this.utils.derivePlayerAddress(user)[0],
                        user: user,
                        payer: payer != null ? payer : this.provider.publicKey,
                        systemProgram: web3_js_1.SystemProgram.programId,
                    }];
            });
        }); };
        this.initiateMergeAccounts = function (user, mergeAccount, payer) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, {
                        user: user,
                        payer: payer != null ? payer : this.provider.publicKey,
                        playerAccount: this.utils.derivePlayerAddress(user)[0],
                        mergeAccount: mergeAccount,
                        systemProgram: web3_js_1.SystemProgram.programId,
                    }];
            });
        }); };
        this.addAchievementAccounts = function (game, authority, nextAchievement, payer) { return __awaiter(_this, void 0, void 0, function () {
            var newAchievement, gameAccount, id;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        newAchievement = nextAchievement;
                        if (!(newAchievement === undefined)) return [3, 2];
                        return [4, this.program.account.game.fetch(game)];
                    case 1:
                        gameAccount = _a.sent();
                        id = gameAccount.achievementCount.addn(1);
                        newAchievement = this.utils.deriveAchievementAddress(id, game)[0];
                        _a.label = 2;
                    case 2: return [2, {
                            newAchievement: newAchievement,
                            game: game,
                            payer: payer != null ? payer : this.provider.publicKey,
                            authority: authority,
                            systemProgram: web3_js_1.SystemProgram.programId,
                        }];
                }
            });
        }); };
        this.addLeaderboardAccounts = function (game, authority, nextLeaderboard, nullTopEntries, payer) { return __awaiter(_this, void 0, void 0, function () {
            var newLeaderBoard, gameAccount, id, topEntries;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        newLeaderBoard = nextLeaderboard;
                        if (!(nextLeaderboard !== undefined)) return [3, 1];
                        newLeaderBoard = nextLeaderboard;
                        return [3, 3];
                    case 1: return [4, this.program.account.game.fetch(game)];
                    case 2:
                        gameAccount = _a.sent();
                        id = gameAccount.leaderboardCount.addn(1);
                        newLeaderBoard = this.utils.deriveLeaderBoardAddress(id, game)[0];
                        _a.label = 3;
                    case 3:
                        if (nullTopEntries !== undefined && nullTopEntries) {
                            topEntries = null;
                        }
                        else {
                            topEntries = this.utils.deriveLeaderTopEntriesAddress(newLeaderBoard)[0];
                        }
                        return [2, {
                                authority: authority,
                                game: game,
                                payer: payer != null ? payer : this.provider.publicKey,
                                leaderboard: newLeaderBoard,
                                topEntries: topEntries,
                                systemProgram: web3_js_1.SystemProgram.programId,
                            }];
                }
            });
        }); };
        this.addFtRewardAccounts = function (authority, newReward, achievement, sourceTokenAccount, tokenAccountOwner, mint, game, payer) { return __awaiter(_this, void 0, void 0, function () {
            var gameAddress, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(game !== null && game !== void 0)) return [3, 1];
                        _a = game;
                        return [3, 3];
                    case 1: return [4, this.program.account.achievement.fetch(achievement)];
                    case 2:
                        _a = (_b.sent()).game;
                        _b.label = 3;
                    case 3:
                        gameAddress = _a;
                        return [2, {
                                authority: authority,
                                payer: payer != null ? payer : this.provider.publicKey,
                                game: gameAddress,
                                achievement: achievement,
                                newReward: newReward,
                                rewardTokenMint: mint,
                                delegateFromTokenAccount: sourceTokenAccount,
                                tokenAccountOwner: tokenAccountOwner,
                                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                                systemProgram: web3_js_1.SystemProgram.programId,
                            }];
                }
            });
        }); };
        this.addNftRewardAccounts = function (authority, newReward, achievement, collectionMint, collectionUpdateAuthority, game, payer) { return __awaiter(_this, void 0, void 0, function () {
            var gameAddress, _a, collectionMetadata, metadataProgram;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(game !== null && game !== void 0)) return [3, 1];
                        _a = game;
                        return [3, 3];
                    case 1: return [4, this.program.account.achievement.fetch(achievement)];
                    case 2:
                        _a = (_b.sent()).game;
                        _b.label = 3;
                    case 3:
                        gameAddress = _a;
                        collectionMetadata = null;
                        metadataProgram = null;
                        if (collectionMint !== undefined) {
                            if (collectionUpdateAuthority === undefined) {
                                throw new Error("Collection update authority should be defined");
                            }
                            collectionMetadata = this.utils.deriveMetadataAddress(collectionMint)[0];
                            metadataProgram = constants_1.TOKEN_METADATA_PROGRAM_ID;
                        }
                        return [2, {
                                authority: authority,
                                payer: payer != null ? payer : this.provider.publicKey,
                                game: gameAddress,
                                achievement: achievement,
                                newReward: newReward,
                                systemProgram: web3_js_1.SystemProgram.programId,
                                rewardCollectionMint: collectionMint !== null && collectionMint !== void 0 ? collectionMint : null,
                                collectionUpdateAuth: collectionUpdateAuthority !== null && collectionUpdateAuthority !== void 0 ? collectionUpdateAuthority : null,
                                collectionMetadata: collectionMetadata,
                                tokenMetadataProgram: metadataProgram !== null && metadataProgram !== void 0 ? metadataProgram : null,
                            }];
                }
            });
        }); };
        this.registerMergeApprovalAccounts = function (user, mergeAccount) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, {
                        user: user,
                        playerAccount: this.utils.derivePlayerAddress(user)[0],
                        mergeAccount: mergeAccount,
                    }];
            });
        }); };
        this.claimFtRewardAccounts = function (authority, achievement, user, reward, game) { return __awaiter(_this, void 0, void 0, function () {
            var rewardAddress, gameAddress, account, achievementAccount, playerAccount, playerAchievement, idlAccount, rewardAccount, mint;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(reward === undefined || game === undefined)) return [3, 2];
                        return [4, this.program.account.achievement.fetch(achievement)];
                    case 1:
                        account = _a.sent();
                        achievementAccount = state_1.AchievementAccount.fromIdlAccount(account, achievement);
                        if (achievementAccount.reward === null) {
                            throw new Error("No reward for achievement");
                        }
                        rewardAddress = achievementAccount.reward;
                        gameAddress = achievementAccount.game;
                        return [3, 3];
                    case 2:
                        rewardAddress = reward;
                        gameAddress = game;
                        _a.label = 3;
                    case 3:
                        playerAccount = this.utils.derivePlayerAddress(user)[0];
                        playerAchievement = this.utils.derivePlayerAchievementAddress(user, achievement)[0];
                        return [4, this.program.account.reward.fetch(rewardAddress)];
                    case 4:
                        idlAccount = _a.sent();
                        rewardAccount = state_1.RewardAccount.fromIdlAccount(idlAccount, rewardAddress);
                        if (rewardAccount.FungibleToken === undefined) {
                            throw new Error("Not a fungible-token reward");
                        }
                        mint = rewardAccount.FungibleToken.mint;
                        return [2, {
                                user: user,
                                authority: authority,
                                playerAccount: playerAccount,
                                game: gameAddress,
                                achievement: achievement,
                                reward: rewardAddress,
                                playerAchievement: playerAchievement,
                                sourceTokenAccount: rewardAccount.FungibleToken.account,
                                userTokenAccount: this.utils.deriveAssociatedTokenAddress(mint, user),
                                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                                mint: mint,
                            }];
                }
            });
        }); };
        this.claimNftRewardAccounts = function (authority, achievement, mint, user, reward, game, payer) { return __awaiter(_this, void 0, void 0, function () {
            var rewardAddress, gameAddress, account, achievementAccount, playerAccount, playerAchievement, metadata, masterEdition, userAta, claim;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(reward === undefined || game === undefined)) return [3, 2];
                        return [4, this.program.account.achievement.fetch(achievement)];
                    case 1:
                        account = _a.sent();
                        achievementAccount = state_1.AchievementAccount.fromIdlAccount(account, achievement);
                        if (achievementAccount.reward === null) {
                            throw new Error("No reward for achievement");
                        }
                        rewardAddress = achievementAccount.reward;
                        gameAddress = achievementAccount.game;
                        return [3, 3];
                    case 2:
                        rewardAddress = reward;
                        gameAddress = game;
                        _a.label = 3;
                    case 3:
                        playerAccount = this.utils.derivePlayerAddress(user)[0];
                        playerAchievement = this.utils.derivePlayerAchievementAddress(user, achievement)[0];
                        metadata = this.utils.deriveMetadataAddress(mint)[0];
                        masterEdition = this.utils.deriveEditionAddress(mint)[0];
                        userAta = this.utils.deriveAssociatedTokenAddress(mint, user);
                        claim = this.utils.deriveNftClaimAddress(rewardAddress, mint)[0];
                        return [2, {
                                user: user,
                                authority: authority,
                                playerAccount: playerAccount,
                                game: gameAddress,
                                achievement: achievement,
                                reward: rewardAddress,
                                playerAchievement: playerAchievement,
                                payer: payer != null ? payer : this.provider.publicKey,
                                claim: claim,
                                newMint: mint,
                                newMetadata: metadata,
                                newMasterEdition: masterEdition,
                                mintTo: userAta,
                                tokenMetadataProgram: constants_1.TOKEN_METADATA_PROGRAM_ID,
                                associatedTokenProgram: spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID,
                                systemProgram: web3_js_1.SystemProgram.programId,
                                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                                rent: web3_js_1.SYSVAR_RENT_PUBKEY,
                            }];
                }
            });
        }); };
        this.registerPlayerEntryAccounts = function (user, leaderboard, game, payer) { return __awaiter(_this, void 0, void 0, function () {
            var gameAddress, _a, playerAccount, newList;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(game !== null && game !== void 0)) return [3, 1];
                        _a = game;
                        return [3, 3];
                    case 1: return [4, this.program.account.leaderBoard.fetch(leaderboard)];
                    case 2:
                        _a = (_b.sent()).game;
                        _b.label = 3;
                    case 3:
                        gameAddress = _a;
                        playerAccount = this.utils.derivePlayerAddress(user)[0];
                        newList = this.utils.derivePlayerScoresListAddress(user, leaderboard)[0];
                        return [2, {
                                user: user,
                                payer: payer != null ? payer : this.provider.publicKey,
                                playerAccount: playerAccount,
                                newList: newList,
                                game: gameAddress,
                                leaderboard: leaderboard,
                                systemProgram: web3_js_1.SystemProgram.programId,
                            }];
                }
            });
        }); };
        this.submitScoreAccounts = function (user, authority, leaderboard, game, payer) { return __awaiter(_this, void 0, void 0, function () {
            var leaderboardAccount, gameAddress, playerAccount, playerScores, topEntries;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.program.account.leaderBoard.fetch(leaderboard)];
                    case 1:
                        leaderboardAccount = _a.sent();
                        gameAddress = game !== null && game !== void 0 ? game : leaderboardAccount.game;
                        playerAccount = this.utils.derivePlayerAddress(user)[0];
                        playerScores = this.utils.derivePlayerScoresListAddress(user, leaderboard)[0];
                        topEntries = leaderboardAccount.topEntries;
                        return [2, {
                                payer: payer != null ? payer : this.provider.publicKey,
                                playerAccount: playerAccount,
                                authority: authority,
                                game: gameAddress,
                                leaderboard: leaderboard,
                                playerScores: playerScores,
                                topEntries: topEntries,
                                systemProgram: web3_js_1.SystemProgram.programId,
                            }];
                }
            });
        }); };
        this.updateAchievementAccounts = function (authority, achievement, game) { return __awaiter(_this, void 0, void 0, function () {
            var gameAddress, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(game !== null && game !== void 0)) return [3, 1];
                        _a = game;
                        return [3, 3];
                    case 1: return [4, this.program.account.achievement.fetch(achievement)];
                    case 2:
                        _a = (_b.sent()).game;
                        _b.label = 3;
                    case 3:
                        gameAddress = _a;
                        return [2, {
                                authority: authority,
                                game: gameAddress,
                                achievement: achievement,
                            }];
                }
            });
        }); };
        this.unlockPlayerAchievementAccounts = function (user, authority, achievement, leaderboard, game, payer) { return __awaiter(_this, void 0, void 0, function () {
            var playerAccount, gameAddress, _a, playerEntryList, newPlayerAchievement;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        playerAccount = this.utils.derivePlayerAddress(user)[0];
                        if (!(game !== null && game !== void 0)) return [3, 1];
                        _a = game;
                        return [3, 3];
                    case 1: return [4, this.program.account.achievement.fetch(achievement)];
                    case 2:
                        _a = (_b.sent()).game;
                        _b.label = 3;
                    case 3:
                        gameAddress = _a;
                        playerEntryList = this.utils.derivePlayerScoresListAddress(user, leaderboard)[0];
                        newPlayerAchievement = this.utils.derivePlayerAchievementAddress(user, achievement)[0];
                        return [2, {
                                payer: payer != null ? payer : this.provider.publicKey,
                                playerAccount: playerAccount,
                                playerScores: playerEntryList,
                                game: gameAddress,
                                achievement: achievement,
                                authority: authority,
                                playerAchievement: newPlayerAchievement,
                            }];
                }
            });
        }); };
        this.updateGameAccounts = function (game, authority, payer) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, {
                        payer: payer != null ? payer : this.provider.publicKey,
                        game: game,
                        authority: authority,
                        systemProgram: web3_js_1.SystemProgram.programId,
                    }];
            });
        }); };
        this.updateLeaderboardAccounts = function (authority, leaderboard, game, topEntries) { return __awaiter(_this, void 0, void 0, function () {
            var gameAddress, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(game !== null && game !== void 0)) return [3, 1];
                        _a = game;
                        return [3, 3];
                    case 1: return [4, this.program.account.leaderBoard.fetch(leaderboard)];
                    case 2:
                        _a = (_b.sent()).game;
                        _b.label = 3;
                    case 3:
                        gameAddress = _a;
                        return [2, {
                                authority: authority,
                                game: gameAddress,
                                leaderboard: leaderboard,
                                topEntries: topEntries !== null && topEntries !== void 0 ? topEntries : null,
                            }];
                }
            });
        }); };
        this.updatePlayerAccounts = function (user) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, {
                        user: user,
                        playerAccount: this.utils.derivePlayerAddress(user)[0],
                    }];
            });
        }); };
        this.verifyNftRewardAccounts = function (user, achievement, mint, reward, game, payer) { return __awaiter(_this, void 0, void 0, function () {
            var rewardAddress, gameAddress, account, achievementAccount, playerAccount, playerAchievement, claim, metadata, rewardAccount, _a, _b, collectionMint, collectionMetadata, collectionEdition;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!(reward === undefined || game === undefined)) return [3, 2];
                        return [4, this.program.account.achievement.fetch(achievement)];
                    case 1:
                        account = _d.sent();
                        achievementAccount = state_1.AchievementAccount.fromIdlAccount(account, achievement);
                        if (achievementAccount.reward === null) {
                            throw new Error("No reward for achievement");
                        }
                        rewardAddress = achievementAccount.reward;
                        gameAddress = achievementAccount.game;
                        return [3, 3];
                    case 2:
                        rewardAddress = reward;
                        gameAddress = game;
                        _d.label = 3;
                    case 3:
                        playerAccount = this.utils.derivePlayerAddress(user)[0];
                        playerAchievement = this.utils.derivePlayerAchievementAddress(user, achievement)[0];
                        claim = this.utils.deriveNftClaimAddress(rewardAddress, mint)[0];
                        metadata = this.utils.deriveMetadataAddress(mint)[0];
                        _b = (_a = state_1.RewardAccount).fromIdlAccount;
                        return [4, this.program.account.reward.fetch(rewardAddress)];
                    case 4:
                        rewardAccount = _b.apply(_a, [_d.sent(), rewardAddress]);
                        if (rewardAccount.NonFungibleToken === undefined ||
                            ((_c = rewardAccount.NonFungibleToken) === null || _c === void 0 ? void 0 : _c.collection) === null) {
                            throw new Error("No collection to verify rewards for.");
                        }
                        collectionMint = rewardAccount.NonFungibleToken.collection;
                        collectionMetadata = this.utils.deriveMetadataAddress(collectionMint)[0];
                        collectionEdition = this.utils.deriveEditionAddress(collectionMint)[0];
                        return [2, {
                                payer: payer != null ? payer : this.provider.publicKey,
                                user: user,
                                playerAccount: playerAccount,
                                achievement: achievement,
                                game: gameAddress,
                                reward: rewardAddress,
                                playerAchievement: playerAchievement,
                                mint: mint,
                                claim: claim,
                                metadataToVerify: metadata,
                                collectionMint: collectionMint,
                                collectionEdition: collectionEdition,
                                collectionMetadata: collectionMetadata,
                                tokenMetadataProgram: constants_1.TOKEN_METADATA_PROGRAM_ID,
                            }];
                }
            });
        }); };
        this.program = new anchor_1.Program(soar_1.IDL, programId, provider);
        this.utils = new utils_1.Utils(this.program.programId);
    }
    return AccountsBuilder;
}());
exports.AccountsBuilder = AccountsBuilder;
//# sourceMappingURL=accountsBuilder.js.map