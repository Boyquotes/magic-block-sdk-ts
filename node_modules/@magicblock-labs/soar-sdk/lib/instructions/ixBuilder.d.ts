import { type Soar } from "../idl/soar";
import { type AnchorProvider, Program } from "@coral-xyz/anchor";
import { Transaction, type PublicKey, type TransactionInstruction, type Signer, type ConfirmOptions } from "@solana/web3.js";
import { type InitializeGameArgs, type AddAchievementArgs, type AddNftRewardArgs, type AddFtRewardArgs, type InitializePlayerArgs, type InitMergeArgs, type SubmitScoreArgs, type UpdateAchievementArgs, type UpdateGameArgs, type UpdateLeaderboardArgs, type UpdatePlayerArgs, type AddLeaderBoardArgs } from "../types";
import { Utils } from "../utils";
import { AccountsBuilder } from "./accountsBuilder";
export declare class InstructionBuilder {
    private readonly provider;
    instructions: TransactionInstruction[];
    signers: Signer[];
    readonly program: Program<Soar>;
    readonly utils: Utils;
    readonly accounts: AccountsBuilder;
    constructor(provider: AnchorProvider, programId: PublicKey);
    append: (instructions: TransactionInstruction[]) => InstructionBuilder;
    initGameStep(args: InitializeGameArgs, newGame: PublicKey, creator?: PublicKey): Promise<[
        InstructionBuilder,
        Awaited<ReturnType<typeof AccountsBuilder.prototype.initializeGameAccounts>>
    ]>;
    initPlayerStep(args: InitializePlayerArgs, user: PublicKey, payer?: PublicKey): Promise<[
        InstructionBuilder,
        Awaited<ReturnType<typeof AccountsBuilder.prototype.initializePlayerAccounts>>
    ]>;
    updateGameStep(args: UpdateGameArgs, game: PublicKey, authority: PublicKey, payer?: PublicKey): Promise<[
        InstructionBuilder,
        Awaited<ReturnType<typeof AccountsBuilder.prototype.updateGameAccounts>>
    ]>;
    updatePlayerStep(args: UpdatePlayerArgs, user: PublicKey): Promise<[
        InstructionBuilder,
        Awaited<ReturnType<typeof AccountsBuilder.prototype.updatePlayerAccounts>>
    ]>;
    initMergeStep(args: InitMergeArgs, user: PublicKey, newMergeAccount: PublicKey, payer?: PublicKey): Promise<[
        InstructionBuilder,
        Awaited<ReturnType<typeof AccountsBuilder.prototype.initiateMergeAccounts>>
    ]>;
    registerMergeApprovalStep(user: PublicKey, mergeAccount: PublicKey): Promise<[
        InstructionBuilder,
        Awaited<ReturnType<typeof AccountsBuilder.prototype.registerMergeApprovalAccounts>>
    ]>;
    addAchievementStep(args: AddAchievementArgs, game: PublicKey, authority: PublicKey, nextAchievement?: PublicKey, payer?: PublicKey): Promise<[
        InstructionBuilder,
        Awaited<ReturnType<typeof AccountsBuilder.prototype.addAchievementAccounts>>
    ]>;
    addLeaderBoardStep(args: AddLeaderBoardArgs, gameAddress: PublicKey, authority: PublicKey, nextLeaderboard?: PublicKey, payer?: PublicKey): Promise<[
        InstructionBuilder,
        Awaited<ReturnType<typeof AccountsBuilder.prototype.addLeaderboardAccounts>>
    ]>;
    updateLeaderboardStep(args: UpdateLeaderboardArgs, authority: PublicKey, leaderboard: PublicKey, game?: PublicKey, topEntries?: PublicKey): Promise<[
        InstructionBuilder,
        Awaited<ReturnType<typeof AccountsBuilder.prototype.updateLeaderboardAccounts>>
    ]>;
    registerPlayerEntryStep(user: PublicKey, leaderboard: PublicKey, game?: PublicKey, payer?: PublicKey): Promise<[
        InstructionBuilder,
        Awaited<ReturnType<typeof AccountsBuilder.prototype.registerPlayerEntryAccounts>>
    ]>;
    submitScoreStep(args: SubmitScoreArgs, user: PublicKey, authority: PublicKey, leaderboard: PublicKey, game?: PublicKey, payer?: PublicKey): Promise<[
        InstructionBuilder,
        Awaited<ReturnType<typeof AccountsBuilder.prototype.submitScoreAccounts>>
    ]>;
    updateAchievementStep(args: UpdateAchievementArgs, authority: PublicKey, achievement: PublicKey, game?: PublicKey): Promise<[
        InstructionBuilder,
        Awaited<ReturnType<typeof AccountsBuilder.prototype.updateAchievementAccounts>>
    ]>;
    unlockPlayerAchievementStep(user: PublicKey, authority: PublicKey, achievement: PublicKey, leaderboard: PublicKey, game?: PublicKey, payer?: PublicKey): Promise<[
        InstructionBuilder,
        Awaited<ReturnType<typeof AccountsBuilder.prototype.unlockPlayerAchievementAccounts>>
    ]>;
    addFungibleRewardStep(args: AddFtRewardArgs, authority: PublicKey, newReward: PublicKey, achievement: PublicKey, sourceTokenAccount: PublicKey, tokenAccountOwner: PublicKey, mint: PublicKey, game?: PublicKey, payer?: PublicKey): Promise<[
        InstructionBuilder,
        Awaited<ReturnType<typeof AccountsBuilder.prototype.addFtRewardAccounts>>
    ]>;
    addNonFungibleRewardStep(args: AddNftRewardArgs, authority: PublicKey, newReward: PublicKey, achievement: PublicKey, collectionMint?: PublicKey, collectionUpdateAuthority?: PublicKey, game?: PublicKey, payer?: PublicKey): Promise<[
        InstructionBuilder,
        Awaited<ReturnType<typeof AccountsBuilder.prototype.addNftRewardAccounts>>
    ]>;
    claimNftRewardStep(authority: PublicKey, achievement: PublicKey, mint: PublicKey, user: PublicKey, reward?: PublicKey, game?: PublicKey, payer?: PublicKey): Promise<[
        InstructionBuilder,
        Awaited<ReturnType<typeof AccountsBuilder.prototype.claimNftRewardAccounts>>
    ]>;
    claimFtRewardStep(authority: PublicKey, achievement: PublicKey, user: PublicKey, reward?: PublicKey, game?: PublicKey): Promise<[
        InstructionBuilder,
        Awaited<ReturnType<typeof AccountsBuilder.prototype.claimFtRewardAccounts>>
    ]>;
    verifyPlayerNftRewardStep(user: PublicKey, achievement: PublicKey, mint: PublicKey, reward?: PublicKey, game?: PublicKey, payer?: PublicKey): Promise<[
        InstructionBuilder,
        Awaited<ReturnType<typeof AccountsBuilder.prototype.verifyNftRewardAccounts>>
    ]>;
    sign(signers: Signer[]): void;
    build(): Transaction;
    clean(): void;
    complete(opts?: ConfirmOptions): Promise<string>;
}
//# sourceMappingURL=ixBuilder.d.ts.map